[
{
	"uri": "https://libpasta.github.io/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Introduction Introduction to libpasta.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "Our goal is for libpasta to be the clear choice for any developers requiring secure password storage. We target a number of languages, initially supported through the use of SWIG.\nSo far, this means we have simple bindings for C, Java, PHP, python, and Ruby.\nThe SWIG specification for libpasta reveals the simplicity of the API, and a few important caveats:\n# in pasta.h  #include \u0026lt;stdbool.h\u0026gt;extern char * hash_password(const char *password); extern bool verify_password(const char* hash, const char *password); extern void free_string(const char *); extern char * read_password(const char *prompt); These bind to the functions exported by the libpasta-ffi crate.\n# in pasta.i %module pasta %{ #include \u0026lt;pasta.h\u0026gt; %} %typemap(newfree) char * \u0026#34;free_string($1);\u0026#34;; %newobject hash_password; %newobject read_password; %pragma(java) jniclasscode=%{ static { try { System.loadLibrary(\u0026#34;pasta_jni\u0026#34;); } catch (UnsatisfiedLinkError e) { System.err.println(\u0026#34;Native code library failed to load. \\n\u0026#34; + e); System.exit(1); } } %} #include \u0026lt;pasta.h\u0026gt; An important caveat, and reason why these bindings should be preferred, is that the values returned by hash_password and read_password are technically still Rust CStrings. Although these are in the correct layout to be read as string pointers in C, we must take care to return the pointer to Rust so that it can handle freeing the CString. Otherwise we are left with a memory leak.\nNotice that the SWIG bindings have handled this: on returning a CString, the bindings create a new object, and then call free_string on the pointer.\n"
},
{
	"uri": "https://libpasta.github.io/advanced/",
	"title": "Advanced Usage",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Advanced Usage Explore the tools provided by libpasta to help you manage your passwords.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/",
	"title": "Other Languages",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Other Languages Explore the language bindings already supported by libpasta.\n"
},
{
	"uri": "https://libpasta.github.io/technical-details/",
	"title": "Technical Details",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Additional Technical Details Here we give some additional information about the techniques used.\n"
},
{
	"uri": "https://libpasta.github.io/introduction/what-is-libpasta/",
	"title": "What is libpasta?",
	"tags": [],
	"description": "",
	"content": " Password breaches have become a regular occurance. See: Yahoo (twice), LinkedIn, Adobe, Ashley Madison, and a whole lot more.\nFurthermore, with the exception of Yahoo who eventually migrated to bcrypt in 2013, the above examples doubles as a list of \u0026ldquo;how NOT to do password storage\u0026rdquo;: simple hashing, unsalted values, misuse of encryption, and failed password migration. (For more information on why these are bad, see our introduction to password hashing theory).\nThere are two possible interpretations here: first, companies do not put adequate resources in securing passwords; and secondly, getting password hashing right is hard. Furthermore, even if you have followed previous best practice, keeping it right is another technical challenge: algorithm choices, security levels, parameter selection change regularly.\nlibpasta - making passwords painless This library aims to be an all-in-one solution for password storage. In particular, we aim to provide:\n Easy-to-use password storage with strong defaults. Tools to provide parameter tuning for different use cases. Automatic migration of passwords to new algorithms. Cross-platform builds and cross-language bindings.  Secure by default libpasta is ready to work at a production level straight out of the box. We hide any unnecessary decisions from the developer. Together with the support for migrating passwords, libpasta provides a streamlined, easy, and secure password management solution.\nCurrently, the algorithm favoured by libpasta is scrypt. For more details, see algorithm choice.\nEasy password migration Many developers still use insecure password hashing systems, despite it causing embarrassing and significant vulnerabilities should a leak occur.\nOur aim is to help everyone adopt modern algorithms and associated best practices. Hence we have designed libpasta with built-in support for easy password migration.\nThis allows you to migrate an existing password hash database to secure algorithms, without inconveniencing users with password resets. Furthermore, having convenient migration tools makes it easier to keep you up-to-date with what hashing parameters should be as computer performance increases.\nSee basic usage for an example of migrating passwords, or advanced usage for more details.\nTunable Password hashing is relatively slow by design, and setting parameters (the cost of computing the hash) too low can be a vulnerability. Of course this has to be balanced against performance of your libpasta-using application. For times when the default parameters are not sufficient, libpasta helps developers pick good parameters.\nThe tuning tool measures the performance of your system to suggest parameters, as well as doing some sanity checks based on the specifications of the system. The tool will help you avoid setting parameters too aggressively\nSee tuning for more details.\nCross-platform and cross-language While the main library is written in Rust, thanks to the C-style ABI that is exported by Rust libraries, we are able to support many different languages. Similarly, Rust supports compilation over a number of platforms.\nFor more information, see other languages.\n"
},
{
	"uri": "https://libpasta.github.io/technical-details/algorithm-choice/",
	"title": "Algorithm Selection",
	"tags": [],
	"description": "",
	"content": "Currently, we use scrypt as the default algorithm in libpasta. The default parameters are:\nN: 2^14 r: 8 p: 1  This results in a memory requirement of approximately 16MiB and about 0.01 - 0.1 seconds to compute. For many systems, this can be increased, and we suggest using the tuning tools to choose suitable parameters.\n"
},
{
	"uri": "https://libpasta.github.io/introduction/basic-usage/",
	"title": "Basic Usage",
	"tags": [],
	"description": "",
	"content": " The following examples are for the core library written in Rust. See other languages for language bindings and examples. Where possible, the APIs exported by libpasta are identical to those used in the Rust library.\nThe full Rust API documentation can be found here. Or will be found on docs.rs once v0.1 is published.\nPassword Hashes A common scenario is that a particular user has password, which a service will check on each login to authenticate the user.\nJava Python Rust  public class test { public static void main(String argv[]) { String password = pasta.read_password(\u0026#34;Please enter your password:\u0026#34;); String hash = pasta.hash_password(password);  System.out.println(\u0026#34;The hashed password is: \u0026#34; + hash); } }  from pasta import * password = read_password(\u0026#34;Please enter your password:\u0026#34;) hash = hash_password(password) print(\u0026#34;The hashed password is: \u0026#34;, hash)  extern crate libpasta; // We re-export the rpassword crate for CLI password input. use libpasta::rpassword::*; fn main() { let password = prompt_password_stdout(\u0026#34;Please enter your password:\u0026#34;).unwrap(); let password_hash = libpasta::hash_password(password);  println!(\u0026#34;The hashed password is: \u0026#39;{}\u0026#39;\u0026#34;, password_hash); }   The above code randomly generates a salt, and outputs the hash in the following format: $$scrypt-mcf$log_n=14,r=8,p=1$pfJFg/hVSthuA5l....\nDetails for how this is serialized can be found in the technical details chapter. This adheres to libpasta\u0026rsquo;s strong defaults principle.\nHowever, for using libpasta one only needs to know that hash_password outputs a variable-length string.\nVerifying passwords Now that you have the hashed output, verifying that an inputted password is correct can be done as follows:\nJava Python Rust  extern crate libpasta; use libpasta::rpassword::*; struct User { // ...  password_hash: String, } fn auth_user(user: \u0026amp;User) { let password = prompt_password_stdout(\u0026#34;Enter password:\u0026#34;).unwrap(); if libpasta::verify_password(\u0026amp;user.password_hash, password) {  println!(\u0026#34;The password is correct!\u0026#34;); // ~\u0026gt; Handle correct password  } else { println!(\u0026#34;Incorrect password.\u0026#34;); // ~\u0026gt; Handle incorrect password  } }  from pasta import * class User: password_hash = \u0026#34;\u0026#34; def auth_user(): password = read_password(\u0026#34;Enter password:\u0026#34;) if verify_password(self.password_hash, password): print(\u0026#34;The password is correct!\u0026#34;) # ~\u0026gt; Handle correct password else: print(\u0026#34;Incorrect password.\u0026#34;) # ~\u0026gt; Handle incorrect password  public class User { private String password_hash; public void authUser() { String password = pasta.read_password(\u0026#34;Enter password:\u0026#34;); if(pasta.verify_password(self.password_hash, password)) {  System.out.println(\u0026#34;The password is correct!\u0026#34;); // ~\u0026gt; Handle correct password  } else { System.out.println(\u0026#34;Incorrect password.\u0026#34;); // ~\u0026gt; Handle incorrect password  } } }   Password migration One of the key features of libpasta is the ability to easily migrate passwords to new algorithms.\nSuppose we previously have bcrypt hashes in the following form: $2a$10$175ikf/E6E.73e83..... This a bcrypt hash, structured as $\u0026lt;bcrypt identifier\u0026gt;$\u0026lt;cost\u0026gt;$\u0026lt;salthash\u0026gt;.\nlibpasta includes a simple work flow for migrating passwords to a new algorithm (or new parameterization of an existing algorithm).\nFirst, wrap existing hashes in the new algorithm to ensure their security immediately. Second, as users log in, update the wrapped hashes to just use the new algorithm. Wrapping simply takes an existing hash and re-hashes it with the new algorithm.\nThe following code first wraps an existing hash, and then a move to just using the new algorithm:\n Rust  extern crate libpasta; use libpasta::rpassword::*; struct User { // ...  password_hash: String, } fn migrate_users(users: Vec\u0026lt;\u0026amp;mut User\u0026gt;) { // Step 1: Wrap old hash  for user in users { libpasta::migrate_hash(\u0026amp;mut user.password_hash);  } } fn auth_user(user: \u0026amp;mut User) { // Step 2: Update algorithm during log in  let password = prompt_password_stdout(\u0026#34;Enter password:\u0026#34;).unwrap(); if libpasta::verify_password_update_hash(\u0026amp;mut user.password_hash, password) {  println!(\u0026#34;Password correct, new hash: \\n{}\u0026#34;, user.password_hash); } else { println!(\u0026#34;Password incorrect, hash unchanged: \\n{}\u0026#34;, user.password_hash); } }     In the first step, we do not need the user\u0026rsquo;s password (and can therefore apply this to all user passwords when desired). However, the password hash is now comprised of both a bcrypt computation AND an argon2 computation.\nIn the second step, if the user correctly enters their password, then a new hash is computed from scratch with a fresh salt using the new algorithm. This requires updating the stored version of the hash.\nMore detailed information of password migration can be found here.\nBasic configuration libpasta supports configuration in two ways: directly in code, or using configuration files.\nFor example, suppose we wish to use bcrypt with cost=15 as the default algorithm.\nextern crate libpasta; use libpasta::primitives::Bcrypt; fn main() { libpasta::config::set_primitive(Bcrypt::new(15)); let password_hash = libpasta::hash_password(\u0026#34;hunter2\u0026#34;.to_string()); println!(\u0026#34;The hashed password is: \u0026#39;{}\u0026#39;\u0026#34;, password_hash); // Prints bcrypt hash } Note that once the library is in use, the configuration can no longer be changed.\nAdditionally, values may be set using a configuration file. Written in YAML, these look as follows:\ndefault_primitive: id: scrypt-mcf params: log_n: 12 r: 8 p: 1 This specifies the algorithm to use, in this case, scrypt.\nBy default, libpasta will search the current directory for a file with the name .libpasta.yaml. Alternatively, a specific (relative or absolute) directory can be supplied by running: LIBPASTA_CFG=path/to/cfg/ \u0026lt;app-name\u0026gt;.\nlibpasta will use any parameters set directly, then use any values specified in configuration files, and finally all remaining variables are set to defaults.\nlibpasta also has a parameter selection tool which can optionally output configuration values.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": "We can use the FFI definitions output by Rust directly in C code. However, unlike with the SWIG bindings, we are required to manually free the strings after use, as in the following simple example.\n### in pasta.h #include \u0026lt;stdbool.h\u0026gt; extern char * hash_password(const char *password); extern bool verify_password(const char* hash, const char *password); extern void free_string(const char *); extern char * read_password(const char *prompt);#include \u0026#34;pasta.h\u0026#34;#include \u0026lt;stdio.h\u0026gt; int main(void) { char *hash, *password; hash = hash_password(\u0026#34;hello123\u0026#34;); password = read_password(\u0026#34;Please enter the password (hint: hello123):\u0026#34;); if (verify_password(hash, password)) { printf(\u0026#34;Correct password\\n\u0026#34;); } else { printf(\u0026#34;Sorry, that is incorrect\\n\u0026#34;); } free_string(hash); free_string(password); return 0; } Which is compiled in the usual way:\n$ ls pasta.h test.c $ gcc test.c -lpasta -otest $ ./test Please enter the password (hint: hello123): Correct password"
},
{
	"uri": "https://libpasta.github.io/other-languages/java/",
	"title": "Java",
	"tags": [],
	"description": "",
	"content": "SWIG generates a number of helper files for Java, and a JNI library for use. For convenience, we have packaged these in a .jar file, which can be compiled from scratch using the make install_java command.\nHence, we need the following files: libpasta.so, libpasta_jni.so, and libpasta.jar. Then, the following is sufficient to use the pasta functions:\npublic class test { public static void main(String argv[]) { String hash = pasta.hash_password(\u0026#34;hello123\u0026#34;); String password = pasta.read_password(\u0026#34;Please enter the password (hint: hello123):\u0026#34;); if (pasta.verify_password(hash, password)) { System.out.println(\u0026#34;Correct password\\n\u0026#34;); } else { System.out.println(\u0026#34;Sorry, that is incorrect\\n\u0026#34;); } } } And building the example with:\n$ javac -cp .:../../libpasta.jar test.java $ java -cp .:../../libpasta.jar test Please enter the password (hint: hello123): Correct password"
},
{
	"uri": "https://libpasta.github.io/advanced/keyed/",
	"title": "Keyed Hashes",
	"tags": [],
	"description": "",
	"content": "We are currently developing support for keyed hashes: whether through HMAC or encrypted values. For now, keys are generated and stored locally in memory in the running instance, which means that any passwords which are stored while the application is running will be useless if the application terminates and destroys the keys.\nThe goal is for this structure to be flexible to any kinds of environments with different sources.\nFor example, the following code configures a key for use in libpasta and sets up HMAC to be used as a wrapping function:\nuse libpasta::primitives::hmac::Hmac; // Some proper way of getting a key let key = b\u0026#34;yellow submarine\u0026#34;; libpasta::config::add_key(key); // Construct an HMAC instance and use this as the outer configuration let keyed_function = Hmac::with_key(\u0026amp;digest::SHA256, key); libpasta::config::set_keyed_hash(keyed_function.into()); Using libpasta::hash_function will first hash using the default algorithm, and then afterwards apply the HMAC to the output hash.\nOn the roadmap: support for alternative key sources.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/php/",
	"title": "PHP",
	"tags": [],
	"description": "",
	"content": "For PHP, SWIG generates a pasta.so extension, which can be installed in the system directory (for example, /etc/php/php.ini), and must be enabled. SWIG also generates a pasta.php module file which loads the extension and defines the API for libpasta.\n// In pasta_form.php \u0026lt;?php include(\u0026#34;pasta.php\u0026#34;); $password = $_POST[\u0026#39;password\u0026#39;]; $hash = pasta::hash_password(\u0026#34;hello123\u0026#34;); if (pasta::verify_password($hash, $password)) { echo \u0026#34;Correct password.\u0026#34;; } else { echo \u0026#34;Sorry, that is incorrect\u0026#34;; } ?\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;libpasta PHP example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;pasta_form.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Please enter yor password (hint: hello123) \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;"
},
{
	"uri": "https://libpasta.github.io/advanced/migration/",
	"title": "Password Migration",
	"tags": [],
	"description": "",
	"content": "One of the core principles underlying libpasta is that it should be easy to use best practice password hashing algorithms. Unfortunately, many people are currently not using these algorithms, and furthermore, \u0026ldquo;best practice\u0026rdquo; seems to be very hard to pin down. To solve this, we include support for painless migration, which can even be enabled automatically.\nMigrating a password hash is a subtle problem. The whole point of password storage is that you cannot recover the password. To solve this, libpasta uses the onion approch.\nSuppose we have a password hash H = f(password, salt), and wish to migrate from using algorithm f to algorithm g. Clearly we cannot compute H' = g(password, salt) without first knowing the password.\nHence, we instead compute H' = g(f(password, salt), salt), applying the new hash function on top of the old one.\nIn libpasta, this is represented by a hash of the form:\n$!$argon2i$m=4096,t=3,p=1$$2y-mcf$cost=12$1hKt7q7c... Note we have both argon2i and 2y-mcf (bcrypt) in the hash value. This is a bcrypt hash, with cost 12, which has then been further hashed using Argon2i.\nOnce the user next successfully logs in, this double-hash can simply be updated once again to a standard, single hash.\nTo change hashing algorithms incurs a one-off cost to go through an re-hash all passwords. Migration tools are coming soon. For example, for Ruby on Rails, the following Rake script could be used for password migration:\nnamespace :pasta do desc \u0026#34;Updates all passwords to the default password algorithm\u0026#34; task migrate_passwords: :environment do User.all.each do |user| user.password_digest = Pasta::migrate_hash(user.password_digest) user.save end end end On each subsequent user login, there is an additional overhead incurred: first the cost of computing g(f(password)), which is at worst the cost of two long hashes, plus an additional computation of g(password). However, this migration step only need to happen once per customer, providing a seamless transition experience.\nOf course, there is the possibility that a user does not log in for such a long time that they end up having multiple layers h4(h3(h2(h1(password)))), which could potentially take a long time to migrate, and consume too much storage in the database. Note that the storage only grows linearly in the length of the parameters of h1...h4, since the salt/hash size is fixed. This additional time incurred for an infrequent user is a minor tradeoff for security and convenience.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": "In the future libpasta will be distributed for python through pypi. For now, we can use the _pasta.so and pasta.py files created by SWIG.\nfrom pasta import * hash = hash_password(\u0026#34;hello123\u0026#34;) password = read_password(\u0026#34;Please enter the password (hint: hello123):\u0026#34;) if verify_password(hash, password): print(\u0026#34;Correct password\u0026#34;) else: print(\u0026#34;Sorry, that is incorrect\u0026#34;)"
},
{
	"uri": "https://libpasta.github.io/technical-details/randomness/",
	"title": "Randomness Problems",
	"tags": [],
	"description": "",
	"content": "One benefit of Rust is that it enforces strict error handling in applications. Rust has unwrap and expect methods which are generally used to mean \u0026ldquo;I have no idea how to recover from this particular error, please kill the program\u0026rdquo;.\nFor example, imagine some binary application which is used to count the lines of a file cargo run --bin wc some_file.txt it seems reasonable to panic if some_file.txt is not found, which would communicate this issue clearly.\nAbusing unwrap and expect leads to faulty software. If a password library panicked every time it receives a password hash which was too short (perhaps the database read was truncated for some reason) then it is going to cause significant issues down the road for the web application.\nIn libpasta, there are currently two main sources of failures: hash de/serialization failures, and failure to generate random values. Here we focus on the latter, the former should be covered by a well-defined serialization format and thorough testing/fuzzing.\nWhen calling libpasta::hash_password, the library will attempt to generate a random salt for hashing. If this fails, it is not clear that there is any meaningful strategy which can be performed. Returning this error to the developer significantly complicates the API, without a good chance they can do anything about it. Blocking until randomness is available is also a poor strategy. Hence we look to provide a reasonably fallback strategy.\nOn first use libpasta initializes a number of configuration options (see basic configuration). At this point, libpasta will also test out the default source of randomness (as configured by ring), to initialize a seed. This seed is used as the input to a PRNG, which can deterministically generate salts for new password hashes. If this seed is never recovered by an adversary, there is no problem, and all the salts are still pseudorandom. If, however, the current seed is compromised, all future salts are predictable. However it is still hopefully the case that salts will be per-user distinct which is the main property we wish to achieve.\nHence, instead of failing, here we provide an acceptable fallback mechanism which guarantees the system can continue operating even in unexpected circumstances.\n"
},
{
	"uri": "https://libpasta.github.io/other-languages/ruby/",
	"title": "Ruby",
	"tags": [],
	"description": "",
	"content": "In the future Ruby will be supported through a Ruby gem. For now, SWIG generates a pasta.so extension which can be used directly by Ruby:\nrequire \u0026#39;./pasta.so\u0026#39; hash = Pasta::hash_password(\u0026#34;hello123\u0026#34;) password = Pasta::read_password(\u0026#34;Please enter the password (hint: hello123):\u0026#34;) if Pasta::verify_password(hash, password) puts \u0026#34;Correct password\u0026#34; else puts \u0026#34;Sorry, that is incorrect\u0026#34; end"
},
{
	"uri": "https://libpasta.github.io/technical-details/phc-string-format/",
	"title": "Serializing Hashes",
	"tags": [],
	"description": "",
	"content": "We use the PHC string format, as defined here, to format password hashes produced by libpasta.\nThese take the following format:\n $\u0026lt;id\u0026gt;[$\u0026lt;param\u0026gt;=\u0026lt;value\u0026gt;(,\u0026lt;param\u0026gt;=\u0026lt;value\u0026gt;)*][$\u0026lt;salt\u0026gt;[$\u0026lt;hash\u0026gt;]]  where:\n \u0026lt;id\u0026gt; is the symbolic name for the function \u0026lt;param\u0026gt; is a parameter name \u0026lt;value\u0026gt; is a parameter value \u0026lt;salt\u0026gt; is an encoding of the salt \u0026lt;hash\u0026gt; is an encoding of the hash output  The string is then the concatenation, in that order, of:\n a $ sign; the function symbolic name; optionally, a $ sign followed by one or several parameters, each with a name=value format; the parameters are separated by commas; optionally, a $ sign followed by the (encoded) salt value; optionally, a $ sign followed by the (encoded) hash output (the hash output may be present only if the salt is present).  "
},
{
	"uri": "https://libpasta.github.io/technical-details/supported/",
	"title": "Supported Algorithms",
	"tags": [],
	"description": "",
	"content": " This page lists the hash formats currently supported by libpasta, and the algorithms available for use. For any missing formats/algorithms, please open an issue and/or submit a pull request.\nAlgorithms Currently, libpasta has support for:\n argon2 bcrypt HMAC PBKDF2 scrypt  Formats The following hash-formats are supported automatically by libpasta:\n   Name Format Description     bcrypt legacy format $2[abxy]$\u0026lt;cost\u0026gt;$\u0026lt;salthash\u0026gt; salthash is a non-standard base64 encoding   PHC format $\u0026lt;id\u0026gt;$\u0026lt;params map\u0026gt;$\u0026lt;salt\u0026gt;$\u0026lt;hash\u0026gt; Also referred to as modular crypt format   libpasta specific ($!\u0026lt;PHC hash\u0026gt;)*$\u0026lt;PHC hash\u0026gt; nested MCF hash    "
},
{
	"uri": "https://libpasta.github.io/introduction/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "libpasta is designed to be installed as a system library. Currently, this can be achieved by downloading the repository, compiling it, and moving the library to the system library, e.g /usr/lib.\ngit clone https://github.com/libpasta/libpasta/ # NOT ACTUALLY HERE YET cd libpasta # compiles the library make libpasta # installs the library to ${INSTALL_DIR} - defaults to /usr/lib make install For developing Rust applications, we recommend using it as usual through cargo.\nFor non-Rust applications, follow the above steps to install the library, and follow the instructions for bindings to other languages.\n"
},
{
	"uri": "https://libpasta.github.io/advanced/tuning/",
	"title": "Tuning &amp; Parameter Selection",
	"tags": [],
	"description": "",
	"content": "libpasta comes with a set of secure default algorithm and parameter choices. However, there is no single set of parameters which is suitable for all purposes and we provide tools to help with parameter selection.\nThese tools also have the benefit of working as a benchmarking platform for the target system; if the system performs significantly worse than the expected times, this could result in suboptimal, or even insecure, parameters selected.\nCurrently, running tune -h gives the following output:\n$ tune -h tune 0.0.1 Sam Scott libpasta tuning tool USAGE: tune [FLAGS] [OPTIONS] FLAGS: -h, --help Prints help information -p, --print Output the final result in the configuration file format -V, --version Prints version information -v, --verbose Print test information verbosely OPTIONS: -a, --algorithm \u0026lt;algorithm\u0026gt; Choose the algorithm to tune (default: argon2i) [values: argon2i, bcrypt, scrypt] -t, --target \u0026lt;target\u0026gt; Set the target number of verifications per second to support (defaut: 2) Running simple tune will benchmark various parameter choices (for the default options) until optimal values are found. Configuration options include the algorithm to target, and the default number of logins per second to be supported.\nFinally, the -p flag can be used to produce a libpasta-compatible configuration file.\n$ tune -a scrypt -p CPU speed: 2800 Predicted maximum parameter: 17, with time: 0.437s logN = 5, parallel = 1, read size = 8 ~\u0026gt; memory = 33 KiB 0.0001 s (estimated: 0.0001 s) logN = 6, parallel = 1, read size = 8 ~\u0026gt; memory = 65 KiB 0.0002 s (estimated: 0.0002 s) logN = 7, parallel = 1, read size = 8 ~\u0026gt; memory = 129 KiB 0.0004 s (estimated: 0.0004 s) ... logN = 16, parallel = 1, read size = 8 ~\u0026gt; memory = 65537 KiB 0.1791 s (estimated: 0.2186 s) logN = 17, parallel = 1, read size = 8 ~\u0026gt; memory = 131073 KiB 0.3581 s (estimated: 0.4372 s) logN = 18, parallel = 1, read size = 8 ~\u0026gt; memory = 262145 KiB 0.7151 s (estimated: 0.8743 s) Maximum amount of memory (capped at 2036080 KiB) to achieve \u0026lt; 0.50 s hash = 131088 KiB Recommended: SCrypt, N: 131072, r: 8, p: 1 Default: SCrypt, N: 16384, r: 8, p: 1 Algorithm in configuration format: --- default: Custom primitive: id: \u0026#34;scrypt-mcf\u0026#34; params: log_n: \u0026#34;17\u0026#34; r: \u0026#34;8\u0026#34; p: \u0026#34;1\u0026#34; There are a few interesting things to observe from the output. First of all, notice that the algorithm estimated maximum parameter choice to be 14, taking 0.055s, which is extremely close to the eventual value. This is a sense-check to ensure the system does not perform unexpectedly slow, which might indicate there is another process running which is consuming CPU time and skewing the benchmarks.\nWe left the target number of logins/second (the -t flag) at the default value of 2. This is the recommended amount for interactive logins, such as for websites. For offline applications, for example key derivation for disk encryption, a better value is 1 login every 3 seconds, so -t 0.33.\n"
},
{
	"uri": "https://libpasta.github.io/introduction/password-hashing-theory/",
	"title": "Password hashing theory",
	"tags": [],
	"description": "",
	"content": " Why hash passwords? Let\u0026rsquo;s start with the most common use of passwords: user authentication.\nThe general setting is that an individual has a username and a password, e.g. username: alice and password: hunter2.\nWhen Alice first registers on a website, a new account is created, and the password is stored in the database, so that Alice can prove she is indeed Alice\nid | username | password | creation-date | ... ------------------------------------------------ 1 | alice | hunter2 | 2017-07-14 | ... However, if somebody gains access to this database with malicious intent - whether external hackers, or internal such as a database admin - Alice\u0026rsquo;s password is sitting in the open.\nThis is bad, since Alice is a typical user who likes to re-use the same password across multiple services. Unfortunately, service providers do not have the luxury of assuming all users have unique, high-entropy passwords.\nHence we want to apply a one-way function f to the password, so that nobody can reverse the function f(password) and work out the password, but given a password other-password it is easy to check whether f(password) == f(other-password).\nFrom the wikipedia page, we learn that SHA256 is a candidate one-way function, so we go ahead and use this as our hash function.\nNow, our database might look something like this:\nid | username | password | creation-date | ... -------------------------------------------------- 1 | alice | f52fbd32... | 2017-07-14 | ... This looks better, now the password isn\u0026rsquo;t revealed in the clear. However, this is actually not much better than the cleartext version.\nPlain cryptographic hash functions are not suitable for password hashing functions.\nNot SHA256, not SHA512, and no, not MD5.\nBrute force attacks In the previous example, we simply applied SHA256 to attempt to hide the password.\nThe reason for this is due to one of the fundamental requirements of password hashing algorithms: computing many outputs should be slow.\nAs in the previous example, suppose the attacker has access to the entire password database, with usernames and SHA256 hashes of passwords.\nThe attacker can take a list of common password and simply test every single value against the database. Looking at some commodity hardware, we see that (at the time of writing), $2,400 USD can get you a machine which computes 14,000,000,000,000 hashes per second.\nTo put that in perspective, that can compute every 7 character password made up of a-zA-Z0-9 in less than once second.\nThus we have the great dichotomy of password hashing:\nComputing one password hash should be fast, computing many should be slow\nPassword hashing algorithms To be resistant to a brute-force attack, password hashing algorithms are intentionally made to be slow. As a simple example of this, we have PBKDF2, which is effectively \u0026ldquo;take a cryptographic hash function, and repeat it N times\u0026rdquo;.\nPassword hashing algorithms allow you to choose parameters to slow down the hash function. For interactive logins (think: website login), choosing parameters such that login takes half a second is reasonable.\nIf it takes half a second to compute a single password hash, then guessing a 7 character password as before would take over 55 thousand years.\nHowever, in practice attackers will be using the list of common passwords we mentioned before. Even checking the top 10,000 most passwords will only take about an hour and a half.\nAre these password doomed to be recovered that easily?\nSalting password hashes Before, we saw that many password could be recovered in just an hour and a half. It was implicitly assumed that for any given password, the value stored in the database would be the same for any user. Suppose Alice and Charlie happen to share the same common password:\nid | username | password | creation-date | ... -------------------------------------------------- 1 | alice | cXmBfX44... | 2017-07-14 | ... 2 | bob | BlEi9jKX... | 2017-07-10 | ... 3 | charlie | cXmBfX44... | 2017-07-01 | ... Therefore, we typically add what is called a \u0026ldquo;salt\u0026rdquo; as an input to a password hash. This is a per-user unique value. So we get hash = f(password, salt).\nSince the salt is unique for each user, any brute force attack would need to be mounted on a per-user basis. This is a huge improvement when the attacker is simply interested in recovering as many passwords as possible, but is not necessarily interested in a specific user.\nKeyed hashes People familiar with the basics of cryptography might be wondering why we are not using encryption to protect the password hashes. Indeed, without the key, an encrypted hash is worthless to an attacker.\nSince we do not need decryption algorithms, we can use keyed hash functions such as HMAC instead. This has the same effect, without the key k it will be impossible to compute f_k(password, salt), and thus an attacker would not be able to check whether their password guess is correct.\nProperly protecting the key k is a difficult problem, and compromise of k renders it useless. One effective way is to store k in specialised hardware such as an HSM. However, there exist solutions (warning: PDF) which can help in making keyed solutions more accessible.\nAnother option is to involve a key in the storage mechanism is to encrypt the password hash after hashing. While this has a number of drawbacks compared to using HMAC, one benefit is that it becomes possible to perform key rotation. In the event that the password storage is compromised, but not the encryption key, the key used to store passwords can be updated, rendering the leaked passwords useless.\nWe discuss how to use keys in libpasta in Keyed Hashes.\nMemory hard password hashes In recent times, such as in the password hashing competition, memory hard password hashing has been emphasised as an important part of the design criteria.\nThe main concept here is that it can be significantly cheaper to perform computation on custom hardware (e.g. ASICs), than on a general purpose CPU.\nBefore, we discussed the requirement that it should be fast to compute a single output, but slow to compute many. In order to make this as balanced as possible, we need to ensure that an adversary computing many hashes on custom hardware should not have an advantage over the innocent party using general-purpose hardware.\nAs a potential solution to this, memory-hard hashing functions have been proposed. Reading and writing to memory is an operation which is approximately equally expensive on custom hardware, and the cost to produce ASICs capable of handling more memory is significantly higher. Therefore, the advantage of these custom solutions is reduced.\nSummary Password hashing is essential to protect passwords from being leaked after a data breach. However, is is far from straightforward given the many considerations in play, such as: salting, security-parameters choices, key management, and memory-hardness.\nHence, we created libpasta to help accomodate the needs of the majority of use cases, providing an easy-to-use API which removes the necessity for the technical knowledge to choose appopriate algorithms and parameters.\n"
},
{
	"uri": "https://libpasta.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://libpasta.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://libpasta.github.io/",
	"title": "libpasta",
	"tags": [],
	"description": "",
	"content": ""
}]