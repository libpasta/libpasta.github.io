<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>libpasta</title>
    <link>https://libpasta.github.io/</link>
    <description>Recent content on libpasta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    
	<atom:link href="https://libpasta.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Overview</title>
      <link>https://libpasta.github.io/other-languages/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/overview/</guid>
      <description>Our goal is for libpasta to be the clear choice for any developers requiring secure password storage. We target a number of languages, initially supported through the use of SWIG.
So far, this means we have simple bindings for C, Java, PHP, python, and Ruby.
The SWIG specification for libpasta reveals the simplicity of the API, and a few important caveats:
# in pasta.h  #include &amp;lt;stdbool.h&amp;gt;extern char * hash_password(const char *password); extern bool verify_password(const char* hash, const char *password); extern void free_string(const char *); extern char * read_password(const char *prompt); These bind to the functions exported by the libpasta-ffi crate.</description>
    </item>
    
    <item>
      <title>What is libpasta?</title>
      <link>https://libpasta.github.io/introduction/what-is-libpasta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/introduction/what-is-libpasta/</guid>
      <description>Password breaches have become a regular occurance. See: Yahoo (twice), LinkedIn, Adobe, Ashley Madison, and a whole lot more.
Furthermore, with the exception of Yahoo who eventually migrated to bcrypt in 2013, the above examples doubles as a list of &amp;ldquo;how NOT to do password storage&amp;rdquo;: simple hashing, unsalted values, misuse of encryption, and failed password migration. (For more information on why these are bad, see our introduction to password hashing theory).</description>
    </item>
    
    <item>
      <title>Algorithm Selection</title>
      <link>https://libpasta.github.io/technical-details/algorithm-choice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/algorithm-choice/</guid>
      <description>Currently, we use scrypt as the default algorithm in libpasta. The default parameters are:
N: 2^14 r: 8 p: 1  This results in a memory requirement of approximately 16MiB and about 0.01 - 0.1 seconds to compute. For many systems, this can be increased, and we suggest using the tuning tools to choose suitable parameters.</description>
    </item>
    
    <item>
      <title>Basic Usage</title>
      <link>https://libpasta.github.io/introduction/basic-usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/introduction/basic-usage/</guid>
      <description>The following examples are for the core library written in Rust. See other languages for language bindings and examples. Where possible, the APIs exported by libpasta are identical to those used in the Rust library.
The full Rust API documentation can be found here. Or will be found on docs.rs once v0.1 is published.
Password Hashes A common scenario is that a particular user has password, which a service will check on each login to authenticate the user.</description>
    </item>
    
    <item>
      <title>C</title>
      <link>https://libpasta.github.io/other-languages/c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/c/</guid>
      <description>We can use the FFI definitions output by Rust directly in C code. However, unlike with the SWIG bindings, we are required to manually free the strings after use, as in the following simple example.
### in pasta.h #include &amp;lt;stdbool.h&amp;gt; extern char * hash_password(const char *password); extern bool verify_password(const char* hash, const char *password); extern void free_string(const char *); extern char * read_password(const char *prompt);#include &amp;#34;pasta.h&amp;#34;#include &amp;lt;stdio.h&amp;gt; int main(void) { char *hash, *password; hash = hash_password(&amp;#34;hello123&amp;#34;); password = read_password(&amp;#34;Please enter the password (hint: hello123):&amp;#34;); if (verify_password(hash, password)) { printf(&amp;#34;Correct password\n&amp;#34;); } else { printf(&amp;#34;Sorry, that is incorrect\n&amp;#34;); } free_string(hash); free_string(password); return 0; } Which is compiled in the usual way:</description>
    </item>
    
    <item>
      <title>Java</title>
      <link>https://libpasta.github.io/other-languages/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/java/</guid>
      <description>SWIG generates a number of helper files for Java, and a JNI library for use. For convenience, we have packaged these in a .jar file, which can be compiled from scratch using the make install_java command.
Hence, we need the following files: libpasta.so, libpasta_jni.so, and libpasta.jar. Then, the following is sufficient to use the pasta functions:
public class test { public static void main(String argv[]) { String hash = pasta.hash_password(&amp;#34;hello123&amp;#34;); String password = pasta.</description>
    </item>
    
    <item>
      <title>Keyed Hashes</title>
      <link>https://libpasta.github.io/advanced/keyed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/advanced/keyed/</guid>
      <description>We are currently developing support for keyed hashes: whether through HMAC or encrypted values. For now, keys are generated and stored locally in memory in the running instance, which means that any passwords which are stored while the application is running will be useless if the application terminates and destroys the keys.
The goal is for this structure to be flexible to any kinds of environments with different sources.
For example, the following code configures a key for use in libpasta and sets up HMAC to be used as a wrapping function:</description>
    </item>
    
    <item>
      <title>PHP</title>
      <link>https://libpasta.github.io/other-languages/php/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/php/</guid>
      <description>For PHP, SWIG generates a pasta.so extension, which can be installed in the system directory (for example, /etc/php/php.ini), and must be enabled. SWIG also generates a pasta.php module file which loads the extension and defines the API for libpasta.
// In pasta_form.php &amp;lt;?php include(&amp;#34;pasta.php&amp;#34;); $password = $_POST[&amp;#39;password&amp;#39;]; $hash = pasta::hash_password(&amp;#34;hello123&amp;#34;); if (pasta::verify_password($hash, $password)) { echo &amp;#34;Correct password.&amp;#34;; } else { echo &amp;#34;Sorry, that is incorrect&amp;#34;; } ?&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;libpasta PHP example&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&amp;#34;pasta_form.</description>
    </item>
    
    <item>
      <title>Password Migration</title>
      <link>https://libpasta.github.io/advanced/migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/advanced/migration/</guid>
      <description>One of the core principles underlying libpasta is that it should be easy to use best practice password hashing algorithms. Unfortunately, many people are currently not using these algorithms, and furthermore, &amp;ldquo;best practice&amp;rdquo; seems to be very hard to pin down. To solve this, we include support for painless migration, which can even be enabled automatically.
Migrating a password hash is a subtle problem. The whole point of password storage is that you cannot recover the password.</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>https://libpasta.github.io/other-languages/python/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/python/</guid>
      <description>In the future libpasta will be distributed for python through pypi. For now, we can use the _pasta.so and pasta.py files created by SWIG.
from pasta import * hash = hash_password(&amp;#34;hello123&amp;#34;) password = read_password(&amp;#34;Please enter the password (hint: hello123):&amp;#34;) if verify_password(hash, password): print(&amp;#34;Correct password&amp;#34;) else: print(&amp;#34;Sorry, that is incorrect&amp;#34;)</description>
    </item>
    
    <item>
      <title>Randomness Problems</title>
      <link>https://libpasta.github.io/technical-details/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/randomness/</guid>
      <description>One benefit of Rust is that it enforces strict error handling in applications. Rust has unwrap and expect methods which are generally used to mean &amp;ldquo;I have no idea how to recover from this particular error, please kill the program&amp;rdquo;.
For example, imagine some binary application which is used to count the lines of a file cargo run --bin wc some_file.txt it seems reasonable to panic if some_file.txt is not found, which would communicate this issue clearly.</description>
    </item>
    
    <item>
      <title>Ruby</title>
      <link>https://libpasta.github.io/other-languages/ruby/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/other-languages/ruby/</guid>
      <description>In the future Ruby will be supported through a Ruby gem. For now, SWIG generates a pasta.so extension which can be used directly by Ruby:
require &amp;#39;./pasta.so&amp;#39; hash = Pasta::hash_password(&amp;#34;hello123&amp;#34;) password = Pasta::read_password(&amp;#34;Please enter the password (hint: hello123):&amp;#34;) if Pasta::verify_password(hash, password) puts &amp;#34;Correct password&amp;#34; else puts &amp;#34;Sorry, that is incorrect&amp;#34; end</description>
    </item>
    
    <item>
      <title>Serializing Hashes</title>
      <link>https://libpasta.github.io/technical-details/phc-string-format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/phc-string-format/</guid>
      <description>We use the PHC string format, as defined here, to format password hashes produced by libpasta.
These take the following format:
 $&amp;lt;id&amp;gt;[$&amp;lt;param&amp;gt;=&amp;lt;value&amp;gt;(,&amp;lt;param&amp;gt;=&amp;lt;value&amp;gt;)*][$&amp;lt;salt&amp;gt;[$&amp;lt;hash&amp;gt;]]  where:
 &amp;lt;id&amp;gt; is the symbolic name for the function &amp;lt;param&amp;gt; is a parameter name &amp;lt;value&amp;gt; is a parameter value &amp;lt;salt&amp;gt; is an encoding of the salt &amp;lt;hash&amp;gt; is an encoding of the hash output  The string is then the concatenation, in that order, of:</description>
    </item>
    
    <item>
      <title>Supported Algorithms</title>
      <link>https://libpasta.github.io/technical-details/supported/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/supported/</guid>
      <description>This page lists the hash formats currently supported by libpasta, and the algorithms available for use. For any missing formats/algorithms, please open an issue and/or submit a pull request.
Algorithms Currently, libpasta has support for:
 argon2 bcrypt HMAC PBKDF2 scrypt  Formats The following hash-formats are supported automatically by libpasta:
   Name Format Description     bcrypt legacy format $2[abxy]$&amp;lt;cost&amp;gt;$&amp;lt;salthash&amp;gt; salthash is a non-standard base64 encoding   PHC format $&amp;lt;id&amp;gt;$&amp;lt;params map&amp;gt;$&amp;lt;salt&amp;gt;$&amp;lt;hash&amp;gt; Also referred to as modular crypt format   libpasta specific ($!</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>https://libpasta.github.io/introduction/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/introduction/installation/</guid>
      <description>libpasta is designed to be installed as a system library. Currently, this can be achieved by downloading the repository, compiling it, and moving the library to the system library, e.g /usr/lib.
git clone https://github.com/libpasta/libpasta/ # NOT ACTUALLY HERE YET cd libpasta # compiles the library make libpasta # installs the library to ${INSTALL_DIR} - defaults to /usr/lib make install For developing Rust applications, we recommend using it as usual through cargo.</description>
    </item>
    
    <item>
      <title>Tuning &amp; Parameter Selection</title>
      <link>https://libpasta.github.io/advanced/tuning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/advanced/tuning/</guid>
      <description>libpasta comes with a set of secure default algorithm and parameter choices. However, there is no single set of parameters which is suitable for all purposes and we provide tools to help with parameter selection.
These tools also have the benefit of working as a benchmarking platform for the target system; if the system performs significantly worse than the expected times, this could result in suboptimal, or even insecure, parameters selected.</description>
    </item>
    
    <item>
      <title>Password hashing theory</title>
      <link>https://libpasta.github.io/introduction/password-hashing-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/introduction/password-hashing-theory/</guid>
      <description>Why hash passwords? Let&amp;rsquo;s start with the most common use of passwords: user authentication.
The general setting is that an individual has a username and a password, e.g. username: alice and password: hunter2.
When Alice first registers on a website, a new account is created, and the password is stored in the database, so that Alice can prove she is indeed Alice
id | username | password | creation-date | .</description>
    </item>
    
  </channel>
</rss>