var searchIndex = {};
searchIndex["libpasta"] = {"doc":"Pasta - Password Storage Making passwords painless","items":[[3,"Cleartext","libpasta","A simple wrapper for a password to denote it is a cleartext password.",null,null],[5,"hash_password","","Generates a default hash for a given password.",null,{"inputs":[{"name":"string"}],"output":{"name":"string"}}],[5,"verify_password","","Verifies the provided password matches the inputted hash string.",null,{"inputs":[{"name":"str"},{"name":"string"}],"output":{"name":"bool"}}],[5,"verify_password_update_hash","","Verifies a supplied password against a previously computed password hash, and performs an in-place update of the hash value if the password verifies. Hence this needs to take a mutable `String` reference.",null,{"inputs":[{"name":"string"},{"name":"string"}],"output":{"name":"bool"}}],[5,"migrate_hash","","Migrate the input hash to the current recommended hash.",null,{"inputs":[{"name":"string"}],"output":null}],[0,"rpassword","","Re-export rpassword for convenience.",null,null],[0,"errors","","`libpasta` errors.",null,null],[3,"Error","libpasta::errors","The Error type.",null,null],[12,"0","","The kind of the error.",0,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",1,null],[13,"Deserialize","","Errors from deserializing MCF password hashes.",1,null],[13,"Ring","","Errors originiating from `ring`",1,null],[13,"Serialize","","Errors from serializing to a MCF password hash.",1,null],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"ResultExt","","Additional methods for `Result`, for easy interaction with this crate.",null,null],[10,"chain_err","","If the `Result` is an `Err` then `chain_err` evaluates the closure, which returns some type that can be converted to `ErrorKind`, boxes the original error to store as the cause, then returns a new error containing the original error.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",0,{"inputs":[{"name":"errorkind"},{"name":"state"}],"output":{"name":"error"}}],[11,"from_kind","","",0,null],[11,"with_chain","","",0,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"self"}}],[11,"kind","","",0,null],[11,"iter","","",0,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"chain_err","","",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"self"}}],[11,"backtrace","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"extract_backtrace","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",0,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",0,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"error"}}],[11,"with_boxed_chain","","Construct a chained error from another boxed error and a kind, and generates a backtrace",0,{"inputs":[{"name":"box"},{"name":"k"}],"output":{"name":"error"}}],[11,"kind","","Returns the kind of the error.",0,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","Iterates over the error chain.",0,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"chain_err","","Extends the error chain with a new entry.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"error"}}],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"unspecified"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"deref","","",0,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","A string describing the error kind.",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",1,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"config","libpasta","Configuration module",null,null],[3,"RANDOMNESS_SOURCE","libpasta::config","Global source of randomness for generating salts",null,null],[3,"DEFAULT_PRIM","","Globally-set default `Primitive`. Guaranteed to be a static reference to some `PrimitiveImpl`. Note that accessing this variable finalises the configuration state and further changes cannot be made.",null,null],[3,"DEFAULT_ALG","","Default algorithm to use for new hash computations.",null,null],[5,"from_file","","Adds the configuration specified in the supplied file to the global configuration",null,{"inputs":[{"name":"p"}],"output":null}],[5,"set_primitive","","Set the default hashing primitive to be used",null,{"inputs":[{"name":"primitive"}],"output":null}],[5,"set_keyed_hash","","Use an additional keyed hash function or encryption scheme.",null,{"inputs":[{"name":"primitive"}],"output":null}],[5,"add_key","","Add a new key into the list of configured keys",null,null],[5,"to_string","","Print the global configuration as a YAML-formatted string.",null,{"inputs":[],"output":{"name":"string"}}],[11,"deref","","",3,{"inputs":[{"name":"self"}],"output":{"name":"sod"}}],[11,"initialize","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",4,{"inputs":[{"name":"self"}],"output":{"name":"primitive"}}],[11,"initialize","","",4,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"algorithm"}}],[11,"initialize","","",5,{"inputs":[{"name":"self"}],"output":null}],[0,"key","libpasta","The `key` module is for managing key sources.",null,null],[3,"KEY_STORE","libpasta::key","Global key storage",null,null],[3,"LocalStore","","Structure used as a global store for keys.",null,null],[8,"Store","","A key storage source. Permits retrieving and storing keys.",null,null],[10,"insert","","Insert a new key into the `Store`.",6,null],[10,"get_key","","Get a key from the `Store`.",6,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"deref","","",7,{"inputs":[{"name":"self"}],"output":{"name":"localstore"}}],[11,"initialize","","",7,{"inputs":[{"name":"self"}],"output":null}],[11,"insert","","Insert a new key into the `KeyStore`.",8,null],[11,"get_key","","Get a key from the `KeyStore`.",8,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[0,"hashing","libpasta","Password hashing functionality",null,null],[3,"Output","libpasta::hashing","Represents the output of a password hashing algorithm.",null,null],[12,"alg","","The algorithm used",9,null],[12,"salt","","The salt",9,null],[12,"hash","","The hash output",9,null],[4,"Algorithm","","`libpasta` password hashing algorithms can be nested, which is captured by this recursive enum.",null,null],[13,"Single","","A single instance of a password-hashing primitive.",10,null],[13,"Nested","","The password-hashing algorithm is composed of nested primitives.",10,null],[12,"outer","libpasta::hashing::Algorithm","The outermost layer of the algorithm is a single primitive",10,null],[12,"inner","","The rest of the layers",10,null],[11,"deserialize","libpasta::hashing","",9,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"serialize","","",9,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"serialize","","",10,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"algorithm"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"algorithm"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"algorithm"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"verify","","Verifies that the supplied password matches the hashed value.",9,{"inputs":[{"name":"self"},{"name":"cleartext"}],"output":{"name":"bool"}}],[11,"hash","","Type-safe function to compute the hash of a password.",10,{"inputs":[{"name":"self"},{"name":"cleartext"}],"output":{"name":"output"}}],[11,"hash_with_salt","","Computes the hash output for given password and salt.",10,null],[11,"verify","","Verifies the password, salt and hash are matching by recursively re-computing the hash and verifying the final value.",10,null],[11,"needs_migrating","","Test whether the current 'Algorithm` is sufficiently secure.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"to_wrapped","","Copies `self` into a new `Algorithm` wrapped by `outer`",10,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"self"}}],[11,"into_wrapped","","Moves `self` into a new `Algorithm` wrapped by `outer`",10,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"self"}}],[0,"primitives","libpasta","`Primitive` in `libpasta` refers to the raw hashing algorithms as implemented in many libraries.",null,null],[3,"Argon2","libpasta::primitives","Parameter set for Argon2.",null,null],[3,"Bcrypt","","`bcrypt` parameter set.",null,null],[3,"Hmac","","Password storage strengthening using HMAC.",null,null],[3,"Pbkdf2","","Struct holding `PBKDF2` parameters.",null,null],[3,"RingPbkdf2","","Struct holding `PBKDF2` parameters.",null,null],[3,"Scrypt","","Struct holding `scrypt` parameters.",null,null],[3,"Primitive","","Password hashing primitives",null,null],[12,"0","","",11,null],[4,"Sod","","Enum to hold either static references or reference-counted owned objects. Implements `Deref` to `T` for ease of use. Since internal data is either a static reference, or an `Arc`, cloning is a cheap operation.",null,null],[13,"Static","","Static reference to T",12,null],[13,"Dynamic","","Dynamically allocated T, on the heap, atomically reference-counted.",12,null],[11,"compute","","",13,null],[11,"params_as_vec","","",13,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",13,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"default","","Get the default Argon2i parameter set",13,{"inputs":[],"output":{"name":"primitive"}}],[11,"new","","Creates a new Argon2i instance",13,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"primitive"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"bcrypt"}}],[11,"compute","","",14,null],[11,"params_as_vec","","",14,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",14,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a new `Bcrypt` parameter set.",14,{"inputs":[{"name":"u32"}],"output":{"name":"primitive"}}],[11,"default","","Get the default `Bcrypt` parameter set.",14,{"inputs":[],"output":{"name":"primitive"}}],[11,"with_key","","Construct a new `Hmac` instance with a specified key",15,null],[11,"default","","Gets a default HMAC instance, generating a fresh new key.",15,{"inputs":[],"output":{"name":"primitive"}}],[11,"compute","","Compute the scrypt hash",15,null],[11,"params_as_vec","","Convert parameters into a vector of (key, value) tuples for serializing.",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",15,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","Create a new PBKDF2 instance using defaults.",16,{"inputs":[],"output":{"name":"primitive"}}],[11,"new","","Create  a new PBKDF2 instance.",16,{"inputs":[{"name":"u32"},{"name":"algorithm"}],"output":{"name":"primitive"}}],[11,"compute","","Compute the scrypt hash",16,null],[11,"params_as_vec","","Convert parameters into a vector of (key, value) tuples for serializing.",16,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",16,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","Create a new PBKDF2 instance using defaults.",17,{"inputs":[],"output":{"name":"primitive"}}],[11,"new","","Create  a new PBKDF2 instance.",17,{"inputs":[{"name":"u32"},{"name":"algorithm"}],"output":{"name":"primitive"}}],[11,"compute","","Compute the scrypt hash",17,null],[11,"params_as_vec","","Convert parameters into a vector of (key, value) tuples for serializing.",17,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",17,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"compute","","Compute the scrypt hash",18,null],[11,"params_as_vec","","Convert parameters into a vector of (key, value) tuples for serializing.",18,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"hash_id","","",18,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","Gets the default scrypt instance.",18,{"inputs":[],"output":{"name":"primitive"}}],[11,"new","","Create  a new scrypt instance.",18,{"inputs":[{"name":"u8"},{"name":"u32"},{"name":"u32"}],"output":{"name":"primitive"}}],[11,"from_bytes","","Create  a new Scrypt instance from an array of bytes, the compact format used by scrypt.",18,null],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"option"}}],[11,"lt","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"le","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"gt","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"ge","","",12,{"inputs":[{"name":"self"},{"name":"sod"}],"output":{"name":"bool"}}],[11,"deref","","",12,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[8,"PrimitiveImpl","","Trait defining the functionality of a hashing primitive.",null,null],[10,"compute","","Compute the output of the primitive with input `password` and `salt`.",19,null],[11,"verify","","Verify the password and salt against the hash.",19,null],[10,"params_as_vec","","Output the parameters of the primitive as a list of tuples.",19,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"hash_id","","Return algorithm type as a MCF-compatible hash identifier.",19,{"inputs":[{"name":"self"}],"output":{"name":"hashes"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"primitive"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"option"}}],[11,"lt","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"le","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"gt","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"ge","","",11,{"inputs":[{"name":"self"},{"name":"primitive"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",11,{"inputs":[{"name":"p"}],"output":{"name":"self"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"primitiveimpl"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",19,{"inputs":[{"name":"self"},{"name":"primitiveimpl"}],"output":{"name":"option"}}],[11,"deref","","",11,{"inputs":[{"name":"self"}],"output":{"name":"sod"}}],[11,"from","","",11,null],[11,"from","","",11,null],[11,"from","libpasta","",20,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[14,"benches","","",null,null],[11,"deserialize","libpasta::primitives","",11,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"serialize","","",11,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}]],"paths":[[3,"Error"],[4,"ErrorKind"],[8,"ResultExt"],[3,"RANDOMNESS_SOURCE"],[3,"DEFAULT_PRIM"],[3,"DEFAULT_ALG"],[8,"Store"],[3,"KEY_STORE"],[3,"LocalStore"],[3,"Output"],[4,"Algorithm"],[3,"Primitive"],[4,"Sod"],[3,"Argon2"],[3,"Bcrypt"],[3,"Hmac"],[3,"RingPbkdf2"],[3,"Pbkdf2"],[3,"Scrypt"],[8,"PrimitiveImpl"],[3,"Cleartext"]]};
searchIndex["serde_mcf"] = {"doc":"","items":[[3,"Map","serde_mcf","Represents a JSON key/value type.",null,null],[4,"Value","","Represents any valid JSON value.",null,null],[13,"Null","","Represents a JSON null value.",0,null],[13,"Bool","","Represents a JSON boolean.",0,null],[13,"Number","","Represents a JSON number, whether integer or floating point.",0,null],[13,"String","","Represents a JSON string.",0,null],[13,"Array","","Represents a JSON array.",0,null],[13,"Object","","Represents a JSON object.",0,null],[3,"McfHash","","A generic hash converted from the `ModularCryptFormat`.",null,null],[12,"algorithm","","",1,null],[12,"parameters","","",1,null],[12,"salt","","",1,null],[12,"hash","","",1,null],[4,"Hashes","","",null,null],[13,"Md5Crypt","","",2,null],[13,"Bcrypt","","",2,null],[13,"Bcrypta","","",2,null],[13,"Bcryptx","","",2,null],[13,"Bcrypty","","",2,null],[13,"Bcryptb","","",2,null],[13,"BcryptMcf","","",2,null],[13,"BsdNtHash","","",2,null],[13,"Sha256Crypt","","",2,null],[13,"Sha512Crypt","","",2,null],[13,"SunMd5Crypt","","",2,null],[13,"Sha1Crypt","","",2,null],[13,"AprMd5Crypt","","",2,null],[13,"Argon2i","","",2,null],[13,"Argon2d","","",2,null],[13,"BcryptSha256","","",2,null],[13,"Phpassp","","",2,null],[13,"Phpassh","","",2,null],[13,"Pbkdf2Sha1","","",2,null],[13,"Pbkdf2Sha256","","",2,null],[13,"Pbkdf2Sha512","","",2,null],[13,"Scram","","",2,null],[13,"CtaPbkdf2Sha1","","",2,null],[13,"Scrypt","","",2,null],[13,"Hmac","","",2,null],[13,"Custom","","",2,null],[0,"de","","",null,null],[3,"Error","serde_mcf::de","The Error type.",null,null],[12,"0","","The kind of the error.",3,null],[3,"McfDeserializer","","Deserializer for the MCF format.",null,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",4,null],[13,"Decoding","","",4,null],[13,"Custom","","",4,null],[5,"from_str","","Deserialize the generic type V from a string.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"ResultExt","","Additional methods for `Result`, for easy interaction with this crate.",null,null],[10,"chain_err","","If the `Result` is an `Err` then `chain_err` evaluates the closure, which returns some type that can be converted to `ErrorKind`, boxes the original error to store as the cause, then returns a new error containing the original error.",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",3,{"inputs":[{"name":"errorkind"},{"name":"state"}],"output":{"name":"error"}}],[11,"from_kind","","",3,null],[11,"with_chain","","",3,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"self"}}],[11,"kind","","",3,null],[11,"iter","","",3,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"chain_err","","",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"self"}}],[11,"backtrace","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"extract_backtrace","","",3,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",3,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",3,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"error"}}],[11,"with_boxed_chain","","Construct a chained error from another boxed error and a kind, and generates a backtrace",3,{"inputs":[{"name":"box"},{"name":"k"}],"output":{"name":"error"}}],[11,"kind","","Returns the kind of the error.",3,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","Iterates over the error chain.",3,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"chain_err","","Extends the error chain with a new entry.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"error"}}],[11,"description","","",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"deref","","",3,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","A string describing the error kind.",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",4,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"custom","","",3,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"new","","Create a new deserializer from a string ref.",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[0,"base64","serde_mcf","Additional methods to deserialize to/from byte arrays encoded in base64. Helper methods for serializing byte arryays to/from base64 encoded format.",null,null],[5,"serialize","serde_mcf::base64","",null,{"inputs":[{"name":"t"},{"name":"s"}],"output":{"name":"result"}}],[5,"deserialize","","",null,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"base64bcrypt","serde_mcf","",null,null],[5,"encode_nopad","serde_mcf::base64bcrypt","",null,null],[5,"decode_nopad","","",null,null],[5,"serialize","","Custom deserialize method for `Bcrypt`.",null,null],[5,"deserialize","","Custom deserialize method for `Bcrypt`",null,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"ser","serde_mcf","",null,null],[3,"Error","serde_mcf::ser","The Error type.",null,null],[12,"0","","The kind of the error.",7,null],[3,"McfSerializer","","Serializer for producing MCF-style hashes.",null,null],[3,"McfSeq","","",null,null],[4,"ErrorKind","","The kind of an error.",null,null],[13,"Msg","","A convenient variant for String.",8,null],[13,"Decoding","","",8,null],[13,"Io","","",8,null],[13,"Custom","","",8,null],[13,"Unsupported","","",8,null],[5,"to_string","","Serialize object to a MCF-style hash.",null,{"inputs":[{"name":"s"}],"output":{"name":"result"}}],[6,"Result","","Convenient wrapper around `std::Result`.",null,null],[8,"ResultExt","","Additional methods for `Result`, for easy interaction with this crate.",null,null],[10,"chain_err","","If the `Result` is an `Err` then `chain_err` evaluates the closure, which returns some type that can be converted to `ErrorKind`, boxes the original error to store as the cause, then returns a new error containing the original error.",9,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",7,{"inputs":[{"name":"errorkind"},{"name":"state"}],"output":{"name":"error"}}],[11,"from_kind","","",7,null],[11,"with_chain","","",7,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"self"}}],[11,"kind","","",7,null],[11,"iter","","",7,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"chain_err","","",7,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"self"}}],[11,"backtrace","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"extract_backtrace","","",7,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"from_kind","","Constructs an error from a kind, and generates a backtrace.",7,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"with_chain","","Constructs a chained error from another error and a kind, and generates a backtrace.",7,{"inputs":[{"name":"e"},{"name":"k"}],"output":{"name":"error"}}],[11,"with_boxed_chain","","Construct a chained error from another boxed error and a kind, and generates a backtrace",7,{"inputs":[{"name":"box"},{"name":"k"}],"output":{"name":"error"}}],[11,"kind","","Returns the kind of the error.",7,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"iter","","Iterates over the error chain.",7,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"backtrace","","Returns the backtrace associated with this error.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"chain_err","","Extends the error chain with a new entry.",7,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"error"}}],[11,"description","","",7,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",7,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"deref","","",7,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","A string describing the error kind.",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"from","","",8,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",8,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"custom","","",7,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"serialize_element","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"end","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"serialize_element","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"end","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"serialize_field","","",10,{"inputs":[{"name":"self"},{"name":"str"},{"name":"t"}],"output":{"name":"result"}}],[11,"end","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"serialize_key","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"serialize_value","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"end","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"serialize_entry","","",10,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"result"}}],[0,"legacy","serde_mcf","",null,null],[3,"BcryptHash","serde_mcf::legacy","MCF style `Bcrypt` hash",null,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",11,{"inputs":[{"name":"self"}],"output":{"name":"mcfhash"}}],[11,"fmt","serde_mcf","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"hashes"}],"output":{"name":"bool"}}],[11,"from_id","","",2,{"inputs":[{"name":"str"}],"output":{"name":"option"}}],[11,"to_id","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"new","","Makes a new empty Map.",12,{"inputs":[],"output":{"name":"map"}}],[11,"with_capacity","","Makes a new empty Map with the given initial capacity.",12,{"inputs":[{"name":"usize"}],"output":{"name":"map"}}],[11,"clear","","Clears the map, removing all values.",12,null],[11,"get","","Returns a reference to the value corresponding to the key.",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map.",12,{"inputs":[{"name":"self"},{"name":"string"},{"name":"value"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key was previously in the map.",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"entry","","Gets the given key's corresponding entry in the map for in-place manipulation.",12,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"entry"}}],[11,"len","","Returns the number of elements in the map.",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the map contains no elements.",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"iter","","Gets an iterator over the entries of the map.",12,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Gets a mutable iterator over the entries of the map.",12,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"keys","","Gets an iterator over the keys of the map.",12,{"inputs":[{"name":"self"}],"output":{"name":"keys"}}],[11,"values","","Gets an iterator over the values of the map.",12,{"inputs":[{"name":"self"}],"output":{"name":"values"}}],[11,"fmt","","Display a JSON value as a string.",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","Convert 32-bit floating point number to `Value`",0,{"inputs":[{"name":"f32"}],"output":{"name":"value"}}],[11,"from","","Convert a `Vec` to `Value`",0,{"inputs":[{"name":"vec"}],"output":{"name":"value"}}],[11,"from","","Convert boolean to `Value`",0,{"inputs":[{"name":"bool"}],"output":{"name":"value"}}],[11,"from","","Convert map (with string keys) to `Value`",0,{"inputs":[{"name":"map"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i32"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i8"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"value"}}],[11,"from","","Convert `String` to `Value`",0,{"inputs":[{"name":"string"}],"output":{"name":"value"}}],[11,"from","","Convert 64-bit floating point number to `Value`",0,{"inputs":[{"name":"f64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u32"}],"output":{"name":"value"}}],[11,"from","","Convert string slice to `Value`",0,{"inputs":[{"name":"str"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u16"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u8"}],"output":{"name":"value"}}],[11,"from","","Convert copy-on-write string to `Value`",0,{"inputs":[{"name":"cow"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"isize"}],"output":{"name":"value"}}],[11,"from","","Convert a slice to `Value`",0,null],[11,"from","","",0,{"inputs":[{"name":"i16"}],"output":{"name":"value"}}],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"into_iter","","",12,null],[11,"index_mut","","Write into a `serde_json::Value` using the syntax `value[0] = ...` or `value[\"k\"] = ...`.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"index_mut","","",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"value"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_iter","","Convert an iteratable type to a `Value`",0,{"inputs":[{"name":"i"}],"output":{"name":"value"}}],[11,"from_iter","","",12,{"inputs":[{"name":"t"}],"output":{"name":"map"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"value"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"map"}}],[11,"serialize","","",12,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"serialize","","",0,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize_any","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_option","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_enum","","",0,null],[11,"deserialize_newtype_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bool","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i8","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i16","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u8","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u16","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_char","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_str","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_string","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bytes","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_byte_buf","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_seq","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_map","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_struct","","",0,null],[11,"deserialize_identifier","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_ignored_any","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"value"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"deserialize","","",0,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"deserialize","","",12,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"bool"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"bool"}}],[11,"extend","","",12,null],[11,"index","","Index into a `serde_json::Value` using the syntax `value[0]` or `value[\"k\"]`.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"index","","",12,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"value"}}],[11,"get","","Index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"get_mut","","Mutably index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"is_object","","Returns true if the `Value` is an Object. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_object","","If the `Value` is an Object, returns the associated Map. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_object_mut","","If the `Value` is an Object, returns the associated mutable Map. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_array","","Returns true if the `Value` is an Array. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_array","","If the `Value` is an Array, returns the associated vector. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_array_mut","","If the `Value` is an Array, returns the associated mutable vector. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_string","","Returns true if the `Value` is a String. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_str","","If the `Value` is a String, returns the associated str. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_number","","Returns true if the `Value` is a Number. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_i64","","Returns true if the `Value` is an integer between `i64::MIN` and `i64::MAX`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_u64","","Returns true if the `Value` is an integer between zero and `u64::MAX`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_f64","","Returns true if the `Value` is a number that can be represented by f64.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_i64","","If the `Value` is an integer, represent it as i64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_u64","","If the `Value` is an integer, represent it as u64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_f64","","If the `Value` is a number, represent it as f64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_boolean","","Returns true if the `Value` is a Boolean. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_bool","","If the `Value` is a Boolean, returns the associated bool. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_null","","Returns true if the `Value` is a Null. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_null","","If the `Value` is a Null, returns (). Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"pointer","","Looks up a value by a JSON Pointer.",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"pointer_mut","","Looks up a value by a JSON Pointer and returns a mutable reference to that value.",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}]],"paths":[[4,"Value"],[3,"McfHash"],[4,"Hashes"],[3,"Error"],[4,"ErrorKind"],[8,"ResultExt"],[3,"McfDeserializer"],[3,"Error"],[4,"ErrorKind"],[8,"ResultExt"],[3,"McfSeq"],[3,"BcryptHash"],[3,"Map"]]};
initSearch(searchIndex);
