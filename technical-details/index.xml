<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical Details on libpasta</title>
    <link>https://libpasta.github.io/technical-details/</link>
    <description>Recent content in Technical Details on libpasta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    
	<atom:link href="https://libpasta.github.io/technical-details/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algorithm Selection</title>
      <link>https://libpasta.github.io/technical-details/algorithm-choice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/algorithm-choice/</guid>
      <description>Currently, we use scrypt as the default algorithm in libpasta.</description>
    </item>
    
    <item>
      <title>Randomness Problems</title>
      <link>https://libpasta.github.io/technical-details/randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/randomness/</guid>
      <description>One benefit of Rust is that it enforces strict error handling in applications. Rust has unwrap and expect methods which are generally used to mean &amp;ldquo;I have no idea how to recover from this particular error, please kill the program&amp;rdquo;.
For example, imagine some binary appliation which is used to count the lines of a file cargo run --bin wc some_file.txt it seems reasonable to panic if some_file.txt is not found, which would communicate this issue clearly.</description>
    </item>
    
    <item>
      <title>Serializing Hashes</title>
      <link>https://libpasta.github.io/technical-details/phc-string-format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://libpasta.github.io/technical-details/phc-string-format/</guid>
      <description>We use the PHC string format, as defined here, to format password hashes produced by libpasta.
These take the following format:
 $&amp;lt;id&amp;gt;[$&amp;lt;param&amp;gt;=&amp;lt;value&amp;gt;(,&amp;lt;param&amp;gt;=&amp;lt;value&amp;gt;)*][$&amp;lt;salt&amp;gt;[$&amp;lt;hash&amp;gt;]]  where:
 &amp;lt;id&amp;gt; is the symbolic name for the function &amp;lt;param&amp;gt; is a parameter name &amp;lt;value&amp;gt; is a parameter value &amp;lt;salt&amp;gt; is an encoding of the salt &amp;lt;hash&amp;gt; is an encoding of the hash output  The string is then the concatenation, in that order, of:</description>
    </item>
    
  </channel>
</rss>